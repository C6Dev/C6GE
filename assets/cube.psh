Texture2D    g_Texture;
SamplerState g_Texture_sampler; // By convention, texture samplers must use the '_sampler' suffix

// Light structs and limits (shared with VS)
#define MAX_POINT_LIGHTS 8
#define MAX_SPOT_LIGHTS  8
struct PointLight
{
    float3 Position; float Range;
    float3 Color;    float Intensity;
};
struct SpotLight
{
    float3 Position; float Range;
    float3 Color;    float Intensity;
    float3 Direction; float SpotCos; // cosine of cutoff angle
};

// Match VS cbuffer layout for lighting
cbuffer Constants
{
    float4x4 g_World;
    float4x4 g_WorldViewProj;
    float4x4 g_NormalTranform;

    float4   g_DirLight;   // xyz = direction, w = intensity
    float4   g_Ambient;    // rgb ambient

    uint     g_NumPointLights;
    uint     g_NumSpotLights;
    float2   _pad0;

    // Fixed-size light arrays (sizes must match CPU)
    PointLight g_PointLights[MAX_POINT_LIGHTS];
    SpotLight  g_SpotLights[MAX_SPOT_LIGHTS];
};

struct PSInput 
{ 
    float4 Pos      : SV_POSITION; 
    float3 Normal   : NORMAL;
    float2 UV       : TEXCOORD0;
    float3 WorldPos : TEXCOORD1;
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

float3 ApplyDirectional(float3 N)
{
    float3 L = normalize(-g_DirLight.xyz);
    float  ndotl = max(0.0f, dot(N, L));
    return ndotl * g_DirLight.w * float3(1.0f, 1.0f, 1.0f);
}

float3 ApplyPoint(float3 N, float3 P)
{
    float3 sum = float3(0.0, 0.0, 0.0);
    [loop]
    for (uint i = 0; i < g_NumPointLights; ++i)
    {
        float3 Lvec = g_PointLights[i].Position - P;
        float  dist = length(Lvec);
        if (g_PointLights[i].Range <= 0.0f) continue;
        float  atten = saturate(1.0f - (dist / g_PointLights[i].Range));
        float3 L = dist > 1e-4 ? (Lvec / dist) : float3(0.0, 0.0, 0.0);
        float  ndotl = max(0.0f, dot(N, L));
        sum += ndotl * atten * g_PointLights[i].Intensity * g_PointLights[i].Color;
    }
    return sum;
}

float3 ApplySpot(float3 N, float3 P)
{
    float3 sum = float3(0.0, 0.0, 0.0);
    [loop]
    for (uint i = 0; i < g_NumSpotLights; ++i)
    {
        float3 Lvec = g_SpotLights[i].Position - P;
        float  dist = length(Lvec);
        if (g_SpotLights[i].Range <= 0.0f) continue;
    float3 L = dist > 1e-4 ? (Lvec / dist) : float3(0.0, 0.0, 0.0);
        float  ndotl = max(0.0f, dot(N, L));

        // Hard cutoff cone using cosine of angle
        float  spotCos = dot(-L, normalize(g_SpotLights[i].Direction));
        float  cone = (spotCos >= g_SpotLights[i].SpotCos) ? 1.0f : 0.0f;

        float  atten = saturate(1.0f - (dist / g_SpotLights[i].Range));
        sum += ndotl * atten * cone * g_SpotLights[i].Intensity * g_SpotLights[i].Color;
    }
    return sum;
}

void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
    // Sample base color (treat as albedo)
    float3 albedo = g_Texture.Sample(g_Texture_sampler, PSIn.UV).rgb;

    float3 N = normalize(PSIn.Normal);
    float3 P = PSIn.WorldPos;

    float3 lighting = float3(0.0f, 0.0f, 0.0f);
    // Directional if provided
    if (any(g_DirLight.xyz) && g_DirLight.w > 0.0f)
        lighting += ApplyDirectional(N);
    lighting += ApplyPoint(N, P);
    lighting += ApplySpot(N, P);
    lighting += g_Ambient.rgb; // ambient is zeroed on CPU to ensure black scene by default

    PSOut.Color = float4(albedo * lighting, 1.0f);
    
#ifdef CONVERT_PS_OUTPUT_TO_GAMMA
    // Use fast approximation for gamma correction
    PSOut.Color.rgb = pow(PSOut.Color.rgb, float3(1.0f / 2.2f, 1.0f / 2.2f, 1.0f / 2.2f));
#endif
}